#!/usr/bin/env ruby -i

# This script allows you to install textmate bundles from github like gems
# You will need the "get_bundle" script to do the dirty work of pulling the repo and installing the script

require 'rubygems'
require 'json'
require 'open-uri'
require 'uri'

module TM

  TextWrap = 78
  IndentSpacing = 10
  Indent    = (" " * IndentSpacing)
  Justify = 15
  Delimiter = ": "
  BundleDirectory = "/Library/Application Support/TextMate/Bundles"
  App = File.basename(__FILE__)

  Help = <<-eos

  \033[1m#{App}\033[0m is a utility to search for textmate bundles, download and install
  them, all via a convenient command line interface, much like rubygems.


  Usage:
  ======================================

  # Search for bundles containing the word 'webrat' in
  # the title, description, or author's name.

  \033[1m#{App} search webrat\033[0m


  # Search for bundles containing the word 'rspec' OR
  # 'cucumber' OR 'shoulda' in their title, description,
  # or author's name.

  \033[1m#{App} search rspec cucumber shoulda\033[0m


  # Install a bundle containing the word rspec in its
  # search fields.  If multiple matches exist, #{App}
  # will let you choose which version to install.

  \033[1m#{App} install rspec\033[0m


  # List all installed bundles

  \033[1m#{App} list\033[0m


  # Uninstall bundle matching 'json'.  If you type in a
  # fragment and there are multiple installed bundles that begin
  # with that fragment, #{App} will let you choose which version
  # you'd like to destroy

  \033[1m#{App} uninstall json\033[0m


  # Tell textmate (if it's open) to reload its bundle information,
  # and update menus & controls accordingly

  \033[1m#{App} reload\033[0m


  # Print this help information

  \033[1m#{App} help\033[0m



  eos

end


class String

  def indent(indent=TM::Indent)
    indent + self
  end

  def text_wrap(width=TM::TextWrap, indent=TM::Indent)
     self.gsub /(.{1,#{width}})(\s+|\Z)/, "\\1\n".indent(indent)
   end

  def bold
    "\033[1m" + self + "\033[0m"
  end

end

module TM

  class Bundle


    attr_accessor :result, :repository, :install_output


    def initialize(result=nil, options={})
      @result = result
      @repository   = options[:repo] || git_repo
    end

    def self.installed
      Dir.glob("#{BundleDirectory}/*.tmbundle").sort{|a,b| a.downcase <=> b.downcase }
    end

    def self.list
      installed.each do |b|
        puts File.basename(b)
      end
    end

    def self.select(bundle)
      installed.select{|b| b =~ Regexp.new(bundle + ".*\.tmbundle$") }
    end

    def self.uninstall(bundle)
      bundle_dir = File.basename(bundle)
      FileUtils.rm_r(File.join(BundleDirectory, bundle_dir))
    end

    def short_result
      {:description => result["description"], :repo => repository }
    end

    def bundle_name
      result["name"].gsub("tmbundle",'').gsub(/^[[:punct:]]+|[[:punct:]]+$/,'')
    end

    def git_repo
       "https://github.com/#{@result["username"]}/#{@result["name"]}.git"
    end

    def display_key(key, options={})
      defaults = {:ljust => Justify, :rjust => Justify, :delimiter => Delimiter, :key_prefix => "", :key_suffix => ""}
      options = defaults.merge options

      if options[:bold_key]
        options[:key_prefix] = "\033[1m" + options[:key_prefix]
        options[:key_suffix] = options[:key_suffix] +"\033[0m"
      end
      if options[:title].nil? || options[:title].strip.length == 0
        options[:title] = ""
        options[:delimiter] = ""#(" " * options[:delimiter].length)
        options[:ljust] = 0
      end
      options[:title] ||= key.to_s
      options[:key_prefix] + (options[:title].capitalize + options[:delimiter]).ljust(options[:ljust]) + options[:key_suffix]
    end

    def display_keypair(key, options={})
      defaults = {:title => key.to_s, :ljust => Justify, :rjust => Justify, :delimiter => Delimiter, :key_prefix => "", :key_suffix => "", :value_prefix => "", :value_suffix => ""}
      options = defaults.merge(options)
      if options[:bold]
        options[:bold_value] ||= true
        options[:bold_key] ||= true
      end
      if options[:bold_value]
        options[:value_prefix] = "\033[1m" + options[:value_prefix]
        options[:value_suffix] = options[:value_suffix] +"\033[0m"
      end
      [
        display_key(options[:title], options),
        options[:value_prefix] + ((options[:value] || (key.is_a?(Symbol) && self.methods.include?(key.to_s)) ? self.send(key) : @result[key.to_s]).to_s) + options[:value_suffix]
      ].compact.reject{|s| s.strip == "" }.join
    end



    def display_value(key, options={})
      display_keypair(key, options)
    end

    def extended_display(key, options={})
      #options[:indent] ||= true
      ed = display_value(key, options).to_s
      unless options[:indent] == false
        ed = ed.indent
      end
      if options[:wrap]
        ed = ed.text_wrap
      end
      if options[:newline]
        ed = ("\n" * options[:newline]) + ed
      end
      ed
    end

    def stats
      "\n" + [
        display_value(:followers, :ljust => Justify ),
        display_value(:forks, :ljust => Justify ),
        display_value(:watchers, :ljust => Justify )
      ].map{|v| v.indent(" " * (IndentSpacing + Justify))}.join("\n")
    end

    def short_stats
      "(" + ["followers", "forks", "watchers"].map{|s| result[s.to_s].to_s + " " + s.to_s}.join(", ") + ")"
    end

    def as_selection(index)
       "#{(index + 1).to_s}) #{git_repo.ljust(60)} \033[1m#{short_stats}\033[0m"

    end

    def display_map
      [
        {:v=> "name", :bold => true, :indent => true, :title => "", :value_prefix => "\e[1;32m"},
        {:v => "username", :title => "Author", :bold_value => true, :newline => 1},
        {:v => "homepage"},
        {:v => :repository, :bold_value => true},
        {:v => :stats, :delimiter => "",  :title => ""},
        {:v => "created_at", :newline => 1},
        {:v=> "description", :indent => false, :newline => 2, :title => "", :wrap => true}
        ]
    end

    def to_s
      display_map.map{|d| extended_display(d.delete(:v), d) }.join("\n") + "\n"
    end

    def to_ss
      [
         "\033[1m" + display_value("name") + "\033[0m",
         display_value("username", :title => "Author").indent,
         display_value(:repository).indent,
         display_value("homepage").indent,
         display_value("followers").indent,
         display_value("followers").indent,
         display_value("followers").indent,
         display_value("created_at").indent,
         "\n" + result["description"].text_wrap
      ].join("\n")
    end

    def destination
      File.join(BundleDirectory, "#{bundle_name}.tmbundle")
    end

    def common_install_script
      <<-eos
        bundle_dir="#{BundleDirectory}"
        mkdir -p "$bundle_dir"
        file_name=$(echo -e #{@repository} | grep -o -P "[-\w\.]+$")
        bundle_name=$(echo -e $file_name |  sed -E -e 's/\.[a-zA-Z0-9]+$//g' -e 's/\.tmbundle//g')
        dest="#{destination}"
        rm -Rf "$dest"
      eos
    end

    def git_install_script
      <<-eos
        #{common_install_script}
        git clone #{@repository} "$dest"
        osascript -e 'tell app "TextMate" to reload bundles'
      eos
    end

    def smart_extract_script(archive)
      <<-eos
        arch=#{archive}
        if [ -f $arch ]; then
            case $arch in
                *.tar.bz2)  tar -jxvf $arch        ;;
                *.tar.gz)   tar -zxvf $arch        ;;
                *.bz2)      bunzip2 $arch          ;;
                *.dmg)      hdiutil mount $arch    ;;
                *.gz)       gunzip $arch           ;;
                *.tar)      tar -xvf $arch         ;;
                *.tbz2)     tar -jxvf $arch        ;;
                *.tgz)      tar -zxvf $arch        ;;
                *.zip)      unzip $arch            ;;
                *.Z)        uncompress $arch       ;;
                *)          echo "'$arch' cannot be extracted/mounted via smartextract()" ;;
            esac
        else
            echo "'$arch' is not a valid file"
        fi
      eos
    end

    def archive_install_script
      <<-eos
        #{common_install_script}
        cd $bundle_dir
        if [[ -n $bundle_name ]]
        then
          rm -R "$bundle_dir/$bundle_name"*
        fi
        curl -o "$bundle_dir/$file_name" $1
        #{ smart_extract_script('$bundle_dir/$file_name')}
        bundle=$(find $bundle_dir/$bundle_name | grep -P "tmbundle$")
        if [[ -n $bundle ]]
        then
          cp -R $bundle $bundle_dir
        fi
        non_bundles=$(find $bundle_dir -d 1 | grep -v -P "tmbundle$|^\.")
        echo $non_bundles | xargs -Ixxx rm -Rf "xxx"
        cd $current
        osascript -e 'tell app "TextMate" to reload bundles'
      eos
    end

    def install
      install_output = IO.popen(git_install_script).read
    end


  end
end





class TMBundles

  attr_accessor :response, :results, :search_terms, :full_set


    def initialize(search_terms=nil)
      @search_terms = search_terms
      @full_set = nil
      @results = []
      search
    end

    def self.handle_connection_error(e, url)
      error         = e.class.name.split("::")
      exception     = error[-1]
      lib           = error[0]
      lib           = lib == exception ? "OpenURI"  : lib
      host          = URI.parse(url).host
      error_message =   case exception
                          when "SocketError" : socket_error(e,url)
                          when "HTTPError"   : http_error(e,url)
                        end
      puts error_message.
          gsub(/#URL/,url).
          gsub(/#LIB/,lib).
          gsub(/#MESSAGE/,e.message).
          gsub(/#EXCEPTION/,exception).
          gsub(/#HOST/,host)
      exit 0
    end

    def self.socket_error(e, url)
      <<-eos

        #LIB is raising a #EXCEPTION: \033[1m#{e.message}\033[0m

        Either \033[1m#HOST\033[0m is currently unavailable or your internet connection is down.

        (We were trying to access \033[1m#URL\033[0m)

      eos
    end

    def self.http_code_messages
      {
        "404" => "the page you're attempting to access doesn't exist"
      }
    end

    def self.http_error(e, url)
      <<-eos

        #LIB is raising an #EXCEPTION: \033[1m#MESSAGE\033[0m

        That means #{http_code_messages[e.message.match(/\d{3}/).to_s]}

        (We were trying to access \033[1m#URL\033[0m)

      eos
    end

    def search_description(terms=@search_terms)
      "Searching for \033[1m#{terms.to_a.join(', ')}\033[0m"
    end

    def put_search_description
      puts "\n" + search_description + "\n"
    end


    def short_result(result)
      {:description => result["description"], :repo => git_repo(result) }
    end

    def sample_response
      '{"repositories": [{"name": "haml", "username": "justin"}]}'
    end

    def search(search_terms = @search_terms, options={})
      options[:additive] ||= true
      formatted_terms = search_terms.to_a.join =~ /tmbundle/ ? search_terms.to_a.join : ['tmbundle',search_terms.to_a].flatten.compact.join(' ')
      regex_terms = Regexp.new(search_terms.to_a.join("|"))
      search_url="http://github.com/api/v2/json/repos/search/#{URI.escape(formatted_terms)}"
      if search_terms.nil? && full_set.nil?
        begin
          response = open(search_url).read
        rescue => e
          self.class.handle_connection_error(e,search_url)
        end
        @full_set = JSON.parse(response)["repositories"]
        @full_set.each_with_index do |r,i|
          @full_set[i]["search_terms"] = r.values_at("username", "name", "description").join
        end
      else
        if options[:additive]
          @results += full_set.to_a.select{|r| r["search_terms"] =~  regex_terms}
        else
          @results = full_set.to_a.select{|r| r["search_terms"] =~  regex_terms}
        end
      end
      @results = @results.uniq
      current_results = search_terms.nil? ? full_set : results
      return current_results.uniq
    end


    def display_results(res=nil)
      res ||= results
      to_display = res || search(search_terms)
      to_display.sort{|a,b| a["name"].downcase <=> b["name"].downcase }.map{|r| TM::Bundle.new(r).to_s }.join("\n\n")
    end

    def bash_install_script_from_repo(repo)
      <<-eos
        bundle_dir="/Library/Application Support/TextMate/Bundles"
        mkdir -p "$bundle_dir"
        file_name=$(echo -e #{repo} | grep -o -P "[-\w\.]+$")
        bundle_name=$(echo -e $file_name |  sed -E -e 's/\.[a-zA-Z0-9]+$//g' -e 's/\.tmbundle//g')
        dest=$bundle_dir/$bundle_name.tmbundle
        rm -Rf "$dest"
        git clone #{repo} "$dest"
        osascript -e 'tell app "TextMate" to reload bundles'
      eos
    end

    def install(repo)
      puts repo
      if repo.match(/^(http|git|https):.*\.git$/)
        matching_repo = TM::Bundle.new([], :repo => repo)
      elsif repo.match(/^(http|ftp|https):.*\.(zip|gz|tar.gz|bz2|tar.bz2)$/)
        matching_repo = TM::Bundle.new([], :repo => repo)
      else
        matching_repo = TM::Bundle.new(search(repo).first)
      end
      install_output = matching_repo.install
      puts install_output
    end

end

searcher     = TMBundles.new
search_terms = ARGV[1..-1]
commands     = ["install", "search", "reload","list", "uninstall","help"]
tm_command   = ARGV[0]

unless commands.include?(ARGV[0])
  puts "You must use this command like 'tmbundles search {search terms}' or 'tmbundles install {package name or repository uri}'"
  exit 0
end

if tm_command == "uninstall"
  results = TM::Bundle.select(ARGV[1])
  if results.size > 1
    puts "\nYou are trying to uninstall multiple bundles.  Select the bundle you wish to remove: \n\n"
    results.each_with_index do |r,i|
      puts "#{(i+1)}) #{r}"
    end
    print "\n\nMake your selection: "
    selection = STDIN.gets.chomp
    result = results[selection.to_i - 1]

  else
    result = results.first
  end
  puts "\nYou chose #{result}\n\nUninstalling...\n\n"
  removed = TM::Bundle.uninstall(result)
  puts "#{result} uninstalled" if removed
elsif tm_command == "list"
  TM::Bundle.list
elsif tm_command == "search"
  if search_terms.nil? or search_terms.length == 0
    searcher.search
  else
    search_terms.each{|term| searcher.search(term) }
  end
  puts "\n" + searcher.search_description(search_terms) + "\n\n" + searcher.display_results + "\n\n"
elsif ARGV[0] == "install"
  results = searcher.search(ARGV[1])
  if results.size == 0
    puts "No matches found"
  elsif results.size == 1
    TM::Bundle.new(results.first).install
  else
    puts "\nYour installation attempt found multiple bundles.  Which of the following repositories would you like to install?\n\n"
    results.each_with_index do |r,i|
      b = TM::Bundle.new(r)
      puts b.as_selection(i)
    end
    print "\n\nMake your selection: "
    selection = STDIN.gets.chomp
    result = results[selection.to_i - 1]
    puts "\nYou chose #{selection}: #{result['name']}\n\nInstalling...\n\n"
    bundle = TM::Bundle.new(result)
    bundle.install
    puts "Bundle installed to #{bundle.destination}"
  end
elsif ARGV[0] == "reload"
  IO.popen("osascript -e 'tell app \"TextMate\" to reload bundles'").read
elsif ARGV[0] == "help"
  puts TM::Help
end
